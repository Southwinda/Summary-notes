# 03.22-03.28 回顾



### Attention

- attention种类：
  1. attention for image captioning
  2. attention for machine translation
  3. self-attention
- 

###疑问：

- elmo，bert是否使用了HS、NS的方法来加速训练。
- 万门课程的作业题还是没有答案



### 刷题

#### 数组

- 验证数独

  ```python
  class Solution:
      def isValidSudoku(self, board: List[List[str]]) -> bool:
          result_row, result_col, result_mat = 0, 0 , 0
          for i in range(len(board)):
              for j in range(len(board)):
  
                  content = board[i][j]
                  if content != '.' and (result_row & (1<<(int(content)-1)) == 0):  
                      result_row = result_row | (1<<(int(content)-1)) 
                  elif content != '.' :
                      print("row",i,j)
                      return False
                  
                  content = board[j][i]
                  if content != '.' and (result_col & (1<<(int(content)-1)) == 0):  
                      result_col = result_col | (1<<(int(content)-1)) 
                  elif content != '.' :
                      print("col: ",j,i)
                      return False
                  
                  idx1 = (i//3)*3 + j//3
                  idx2 = (i%3)*3 + j%3
                  content = board[idx1][idx2]
                  if content != '.' and (result_mat & (1<<(int(content)-1)) == 0):  
                      result_mat = result_mat | (1<<(int(content)-1)) 
                  elif content != '.' :
                      print("block: ",idx1,idx2)
                      return False
              result_row, result_col, result_mat = 0, 0 , 0
          return True
  
  ```

- 旋转数组

  ```python
  class Solution:
      def rotate(self, matrix: List[List[int]]) -> None:
          """
          Do not return anything, modify matrix in-place instead.
          """
          size = len(matrix)
          for i in range(size//2):
              start = i
              end = size-i-1
              for j in range(start, end):
                  top = matrix[i][j]
  
                  # left -> top
                  matrix[i][j] = matrix[size -1 - j][i]
  
                  # down -> left
                  matrix[size-j-1][i] = matrix[size-i-1][size-j-1]
  
                  # right -> down
                  matrix[size-i-1][size-j-1] = matrix[j][size-i-1]
  
                  # top -> right
                  matrix[j][size-i-1] =  top
  ```

- 数组中消失的数字（把index也当成一个数组）

  ```python
  class Solution:
      def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
          for i in range(len(nums)):
              idx = abs(nums[i]) - 1
              nums[idx] = -1 * abs(nums[idx])
          return [i+1 for i in range(len(nums)) if nums[i]>0]
  ```

- 寻找数组的中心索引

  ```python
  class Solution:
      def pivotIndex(self, nums: List[int]) -> int:
          sum_total = sum(nums)
          sum_left = 0
          for i, num in enumerate(nums):
              if sum_left == sum_total - sum_left - num:
                  return i
              sum_left += num
          return -1
  ```

#### 递归

- python的递归层数有限制，大约为1000层

- 递归如果每次返回时，调用两个递归，复杂度就是指数级上升。所以可以换成调用一次递归，返回两个值来避免

- 给定a<=b，将b写出a+1 和a*2的步骤的叠加的最短表达式。

  ```python
  def math_calculator(a,b):
  	if a==b:
  		return str(a)
  	if b%2==1:
  		return "(" + math_calculator(a,b-1)+"+1)"
  	if b >=2*a:
  		return  math_calculator(a,b/2) + "*2"
  	return  "(" + math_calculator(a,b-1)+"+1)"
  ```

- 汉诺塔问题（注意helper函数中n的作用，表明要挪动的数字个数，并不是list中有多少数字就移动多少，细品。）

  ```python
  class Solution:
      def hanota(self, A: List[int], B: List[int], C: List[int]) -> None:
          """
          Do not return anything, modify C in-place instead.
          """
          self.helper(len(A),A,B,C)
      def helper(self,n,a,b,c):
          if n ==1:
              c.append(a.pop())
          else:
              self.helper(n-1,a,c,b)
              self.helper(1,a,b,c)
              self.helper(n-1,b,a,c)
  ```

- 求所有的子集

  ```python
  # 回溯法
  class Solution:
      def subsets(self, nums: List[int]) -> List[List[int]]:
          res = []
          lst = []
          self.helper(res,lst,nums,0)
          return res
      def helper(self,res,lst,nums,pos):
          res.append(lst[:])
          for i in range(pos,len(nums)):
              lst.append(nums[i])
              self.helper(res,lst,nums,i+1)
              lst.pop()
  ```

  ```python
  # 纯递归方法
  class Solution:
      def subsets(self, nums: List[int]) -> List[List[int]]:
          if nums == []:
              return [[]]
          res = self.subsets(nums[1:])
          return res + [[nums[0]]+ s for s in res]
  ```

- 求所有的排列

  ```python
  # 回溯
  class Solution:
      def permute(self, nums: List[int]) -> List[List[int]]:
          res = []
          lst = []
          self.helper(res,lst,nums)
          return res
      def helper(self,res,lst,nums):
          if len(lst) == len(nums):
              res.append(lst[:])
          for i in nums:
              if i in lst:
                  continue
              lst.append(i)
              self.helper(res,lst,nums)
              lst.pop()
  
  ```

  ```python
  # 纯递归
  class Solution:
      def permute(self, nums: List[int]) -> List[List[int]]:
          if len(nums) == 0:
              return [[]]
          result = []
          for i in range(len(nums)):
              res = [[nums[i]]+t for t in  self.permute(nums[:i] + nums[i+1:])]
              result.extend(res)
          return result
  ```

  

- bit操作

  - 判断一个数是否是2的幂 `n>0 ? (n&(n-1))==0: false;` 

  - 不用临时变量交换两个数

    ```c
    a ^= b;        //a = a_ ^ b_
    b ^= a;        //b = a_ ^ b_ ^ b_ = a_
    a ^= b;        //a = a_ ^ b_ ^ a_ ^ b_ ^ b_ = b_
    ```

  - 判断一个二进制数中1的位数

    ```c
    //标准法：
    bool bitCount(unsigned int n){
      unsigned int c = 0;
      for (c=0; n; n>>1){
        c += (n&1);
      }
      return c;
    }
    //快速法：
    bool bitCount(unsigned int n){
      unsigned int c = 0;
      for (c=0;n;++c){
        n &= (n-1);
      }
      return c;
    }
    ```

  - 格雷码

    ```c++
    vector<int> binary2Gary(int n){
      vector<int> res ;
      for (int i=0; i<pow(2,n);i++){
        res.push_back(i^(i>>1));
      }
      return res;
    }
    ```

    


## Plan of next week

- 


