# 09.27-10.03 回顾

## 备忘录

- 关于参数初始化
  - https://blog.csdn.net/u012328159/article/details/80025785
- pytorch的部署可以用caffe2（但其实不好用，而且最好会C++）。更简单的方式是借助onnx转换格式，就可以用TensorFlow serving了...
  - https://github.com/onnx/tutorials 
- 



## 项目技巧

- 使用多进程加速

  ```python
  def line_preprocessing(line, args):
      content = line.split('\t')
      seq = text2seq(content[1], args)
      content[1] = ' '.join(seq)
      return '\t'.join(content)
  
  def _line_preprocessing(param):
      return line_preprocessing(*param)
  
  def preprocessing(input_file, output_file, core_num, args):
      with open(input_file, 'r') as f:
          corpus = f.read().strip()
      # Convert some Chinese characters from full forms into half forms.
      corpus = toolkit.full2half(corpus)
      line = corpus.split('\n')
      pool = multiprocessing.Pool(core_num)
  
      param = [[l, args] for l in line]
      line_processed = pool.map(_line_preprocessing, param)
      with open(output_file, 'w') as f:
          f.write('\n'.join(line_processed))
  ```

- 重采样

  ```python
  def over_sample(ids, data, labels):
      print("over sampling")
      labels_counter = Counter(labels)
      print(labels_counter)
      max_count = labels_counter.most_common(1)[0][1]
      p = dict()
      for i in labels_counter.keys():
          p[i] = (max_count - labels_counter[i]) / labels_counter[i]
      print(p)
  
      new_ids = []
      new_data = []
      new_labels = []
      indices = np.arange(len(labels))
      for i in indices:
          new_ids.append(ids[i])
          new_data.append(data[i])
          new_labels.append(labels[i])
          cur_p = p[labels[i]]
          if cur_p > 1:
              for c in range(int(math.sqrt(cur_p)+0.5)):
                  new_ids.append(ids[i])
                  new_data.append(data[i])
                  new_labels.append(labels[i])
          else:
              rand_p = random.random()
              if rand_p < cur_p-0.1:
                  new_ids.append(ids[i])
                  new_data.append(data[i])
                  new_labels.append(labels[i])
  
      indices = np.arange(len(new_labels))
      np.random.shuffle(indices)
  
      return [new_ids[i] for i in indices], np.array(new_data, dtype=np.int64)[indices], np.array(new_labels, dtype=np.int64)[indices]
  
  ```

- 太长的文本可以分段。

- jieba除了分词，还可以返回词性

  ```python
  import jieba.posseg
  pair = jieba.posseg.cut(text)
  for word, flag in pair:
      if flag == 'nr':
          seq.append('[nr]')
      elif flag == 'ns':
          seq.append('[ns]')
      elif flag == 'm':
          seq.append('[m]')
      else:
          seq.append(word)
  ```

- debug mode

  ```python
  debugflag = False
  
  def debug(stri):
      if debugflag:
          print stri
         
  def LogInfo(stri):
      now = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
      print str(now) + ' ' + str(stri)
  ```

  



# Plan of next week

- 


