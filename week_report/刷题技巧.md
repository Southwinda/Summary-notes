# 刷题技巧

## 数组

- 数组，只要是涉及到 $n^2$ 以上的情况，就要想一想，要不要先排个序。

- shuffle数组

- n以内的所有素数

- 螺旋数组

- #### [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/) 

  - 三次逆序
  - 原地修改，无返回值时，逆序可以改变原数据
  - 使用 `nums = nums[-k:] + nums[:-k]` 的方法，需要使用返回值

- #### [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

  - 基础想法：用一个字典进行统计
  - 可以用index代替字典作用，降低空间复杂度

- #### [724. 寻找数组的中心索引](https://leetcode-cn.com/problems/find-pivot-index/)

  - 从左侧开始迭代，比较左侧和&右侧和，相等时返回。否则返回-1 

- #### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/) 

  - 长度为n的数组中有一个数字出现了n/2次，快速找到这个数
  - 哈希：时间O(N)，空间O(N)
  - 排序：时间O(NlogN)，空间O(1)
  - 摩尔投票：时间O(N)，空间O(1) 

- #### [229. 求众数 II](https://leetcode-cn.com/problems/majority-element-ii/)

  - 上面题目加强版，同样适用摩尔投票法



## 递归和回溯

- 回溯的基本步骤：

  ```python
  result = []
  def backtracking(result,path,选择条件):
    if 结束条件:
      result.append(path)
      return
    for i in 选择条件:
      做选择
      backtracking(result,path,选择条件)
      撤销选择
  ```

- 给定a<=b，将b写出a+1 和a*2的步骤的叠加的最短表达式。

- #### [面试题 08.06. 汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci/)

  - 想象函数时怎么设计接口的，参数有哪些

- #### [78. 子集](https://leetcode-cn.com/problems/subsets/) 

  - 纯递归
  - 回溯法

- #### [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

  - 先排序
  - 回溯的时候，某些条件下要减支

- #### [46. 全排列](https://leetcode-cn.com/problems/permutations/) 

  - 递归
  - 回溯法

- #### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/) 

  - 减支条件想清楚 

- #### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/) 

  - 想想那个图

- #### [60. 第k个排列](https://leetcode-cn.com/problems/permutation-sequence/) 

  - 

- #### [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/) 

- 大小为k的排列

- #### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

  - O(N)解法

- #### [15. 三数之和](https://leetcode-cn.com/problems/3sum/) 

  - 先排序，注意减支

- #### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/) 

- #### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/) 

- #### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/) 

- #### [51. N 皇后](https://leetcode-cn.com/problems/n-queens/) 

  - 返回解的数量

- #### [52. N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/) 

  - 返回每种解的情况





## BIT操作

- 判断一个数是否是2的幂
- 不用临时变量交换两个数
- 判断一个二进制数中1的位数



## 分治

- 二分查找的模板

  ```python
  def binarysearch(alist, item):
      if len(alist) == 0:
          return -1
      
      left, right = 0, len(alist) - 1
      while left + 1 < right:
          mid = left + (right - left) // 2
          if alist[mid] == item:
              right = mid
          elif alist[mid] < item:
              left = mid
          elif alist[mid] > item:
              right = mid
      
      if alist[left] == item:
          return left
      if alist[right] == item:
          return right
      
      return -1
  ```

- #### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/) 

  - 注意使用模板

- #### [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/) 

  - 对于一般的旋转数组，有 `nums[l]>=nums[r]` （特例除外），因此可以和右侧进行比较，更严格不易出错（在有重复数字的情况下） 

- #### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) 

- #### [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/) 

- #### [面试题 10.09. 排序矩阵查找](https://leetcode-cn.com/problems/sorted-matrix-search-lcci/) 

- #### [378. 有序矩阵中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/) 

  - 想想那个图怎么画的

- #### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/) 

  - 想想二分是对哪个数组二分
  - 转化为链表（涉及到N个数，长度为N的数组，怎么利用index），体会转化为链表的过程

- #### [57. 插入区间](https://leetcode-cn.com/problems/insert-interval/) 

  - 没仔细复习，有时间再看

- 排序（思路清楚，但是再看看代码怎么写的）

  - 归并
  - 快排 

- #### [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/) 

- #### [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/) 

- #### [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

- #### [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) 

  - 什么时候count增加，增加的数字是多少



## 链表

- 链表的常用技巧
  - 快慢指针
  - pre、cur、nxt指针
- [链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)
- [删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)
- [环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)
- [环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
- [相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)
  - 细节想一下
- [删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)
- [排序链表](https://leetcode-cn.com/problems/sort-list/)
- [分隔链表](https://leetcode-cn.com/problems/partition-list/)
  - 再复习一下
- [反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) 
- [反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
- [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/) 
- [删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)
  - 再复习一下
- [删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)
  - 再复习一下



## 栈和队列

- Stack、Queue、Deque解题的三个问题：

  - What？要把什么放在数据结构中 （技巧：可以放index，放`["", idx]` 二元组等）
  - When to push？
  - WHen to pop？（push、pop的合理使用，可以构成**有序栈**，待入栈元素和栈顶元素比较）

- [用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)
- [用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/) 
  - 动态考虑
- [最小栈](https://leetcode-cn.com/problems/min-stack/) 
- [栈排序](https://leetcode-cn.com/problems/sort-of-stacks-lcci/) 
  - 动态考虑
- [字符串解码](https://leetcode-cn.com/problems/decode-string/) 
  - 难，多体会
- [下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/) 
  - 想想单调栈的入栈出栈流程
- [下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)
  - 第二次的时候不再入栈 
- [每日温度](https://leetcode-cn.com/problems/daily-temperatures/)
  - 想想入栈的是什么
- [滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)



## 哈希

- [两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)
- [存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)
- [存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)
- [子域名访问计数](https://leetcode-cn.com/problems/subdomain-visit-count/)



## 树🌲

- 二叉搜索树
  - 删除操作
- 树的几种题型
  - 递归（树的大小、深度等）
  - 使用循环的方式遍历，借用stack，queue等数据结构
  - level形式的遍历
  - 不同order的遍历结果，构建树
  - path sum
- [二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)
  - 一种递归
  - 一种遍历，仔细想下怎么操作的

- [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

  - 一种从顶到下
  - 一种从底到上（推荐）

- [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/) 

- [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

  ```python
  class Solution:
      def preorderTraversal(self, root: TreeNode) -> List[int]:
          stack = [root]
          res = []
          while stack:
              cur = stack.pop()
              if cur:
                  res.append(cur.val) 
                  stack.append(cur.right)
                  stack.append(cur.left) 
          return res 
  ```

- [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

  ```python
  class Solution:
      def inorderTraversal(self, root: TreeNode) -> List[int]:
          stack = []
          res = []
          node = root
          while True:
              while node :
                  stack.append(node)
                  node = node.left 
              if len(stack) == 0:
                  return res 
              node = stack.pop()
              res.append(node.val)
              node = node.right      # 始终有一个node表示current node，而不是去取栈顶node
              					   # 每次去取栈顶node可能会造成死循环。
          return res 
  ```

- [二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

  ```python
  # 迭代
  class Solution:
      def postorderTraversal(self, root: TreeNode) -> List[int]:
          stack =  [root]
          res = [] 
          while stack:
              node = stack.pop()
              if node:
                  res.append(node.val)
                  stack.append(node.left)
                  stack.append(node.right) 
          return res[::-1]
      
  class Solution:
      def postorderTraversal(self, root: TreeNode) -> List[int]:
          stack = [[root,False] ]
          res = []
          node = root 
          while stack:
              node, visited = stack.pop() 
              if node:
                  if visited:
                      res.append(node.val) 
                  else:
                      stack.append([node, True]) 
                      stack.append([node.right, False]) 
                      # 此处None也要入栈，当节点为None时，进入下一次循环，下一次pop，避免死循环
                      stack.append([node.left, False])
          return res 
  ```

  

- [二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) 

- 











